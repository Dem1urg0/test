Задание 1 
После успешной покупки билетов на событие, данные попадают в список заказов. Список заказов сохраняется в таблице MySql в виде:

id
event_id
event_date
ticket_adult_price
ticket_adult_quantity
ticket_kid_price
ticket_kid_quantity
barcode
user_id
equal_price
created

Где:
id - int(10) - инкрементальный порядковый номер заказа
event_id - int(11) - уникальный ид события. У каждого события есть свое название, описание, расписание, цены и свой уникальный event_id соответственно
event_date - varchar(10) - дата и время на которое были куплены билеты
ticket_adult_price - int(11) - цена взрослого билета на момент покупки
ticket_adult_quantity - int(11) - количество купленных взрослых билетов в этом заказе
ticket_kid_price - int(11) - цена детского билета на момент покупки
ticket_kid_quantity - int(11) - количество купленных детских билетов в этом заказе
barcode - varchar(120) - уникальный штрих код заказа
equal_price - int(11) - общая сумма заказа
created - datetime - дата создания заказа
Задача: написать функцию, которая будет добавлять заказы в эту таблицу.
Аргументы которые функция получает на входе: event_id, event_date, ticket_adult_price, ticket_adult_quantity, ticket_kid_price, ticket_kid_quantity
Нужно сгенерировать barcode, который будет уникальным со случайным набором цифр, он не должен быть порядковым.
Так же, существует некая сторонняя api.site.com. API писать не нужно, возвращаемые данные можно замокать и возвращать в случайном порядке. в которой нужно сделать бронь заказа отправив ей (https://api.site.com/book) event_id, event_date, ticket_adult_price, ticket_adult_quantity, ticket_kid_price, ticket_kid_quantity, barcode. На что она может вернуть либо {message: 'order successfully booked'}, либо {error: 'barcode already exists'}. В случае если получаем ошибку, нужно сгенерировать новый barcode и повторить попытку. Важно учесть, если запрос будет происходить одновременно, не должно возникнуть такой ситуации, что двум разным заказам присвоился один номер.
После успешной брони, нужно отправить на стороннюю апи запрос с подтверждением (https://api.site.com/approve), который принимает только barcode. Ответов может быть 2 варианта - успешный: {message: 'order successfully aproved'} и различные варианты ошибок {error: 'event cancelled'}, {error: 'no tickets'}, {error: 'no seats'}, {error: 'fan removed'}. В случае успеха, сохраняем заказ в БД

Выжимка задания
	Функция должна:
Сгенерировать уникальный barcode — случайный набор цифр, который не является порядковым.
Сделать бронь заказа через сторонний API https://api.site.com/book, передавая следующие параметры: event_id, event_date, ticket_adult_price, ticket_adult_quantity, ticket_kid_price, ticket_kid_quantity, barcode.
Если API возвращает {message: 'order successfully booked'}, то заказ считается забронированным.
Если API возвращает {error: 'barcode already exists'}, необходимо сгенерировать новый barcode и повторить попытку. Важно: при одновременных запросах не должно возникнуть ситуации, когда двум разным заказам присвоится одинаковый barcode.
После успешной брони отправить запрос на подтверждение бронирования через API https://api.site.com/approve, передав только barcode.
Если ответ API: {message: 'order successfully approved'}, сохранить заказ в БД.
Если ответ API содержит ошибки, такие как {error: 'event cancelled'}, {error: 'no tickets'}, {error: 'no seats'}, {error: 'fan removed'}, прекратить выполнение и вернуть ошибку.

Решение
Цель: Создать приложение, которое будет добавлять заказ в базу данных с учетом описанных выше требований.
Описание решения:
Создать класс бронирования — разделить его на две части: сущность и репозиторий.
EBooking.php — Сущность бронирования, содержащая информацию о заказе и функции для проверки данных.
RBooking.php — Репозиторий бронирования, содержащий методы для взаимодействия с API и БД.
Создать абстрактные классы для сущностей и репозиториев:
Entity.php — Базовый класс для сущностей, содержащий методы для проверки данных.
Repository.php — Базовый класс для репозиториев, содержащий методы для работы с БД.
Создать класс для работы с базой данных (DB.php) — использовать PDO для взаимодействия с БД.
Реализовать автозагрузку классов (Autoload.php) — для удобства работы с классами и их зависимостями.
Связи между классами:
Repository.php наследуется в RBooking.php.
Entity.php наследуется в EBooking.php.
RBooking.php через конструктор получает экземпляр класса EBooking.php.
Конструктор Repository.php создает экземпляр DB.php для взаимодействия с БД.
Для DB.php реализовать singleton через trait для обеспечения единственного подключения к БД.
Основные функции классов:
RBooking:
Генерация уникального barcode (можно вынести генерацию в отдельный trait или класс).
Отправка запросов на API через cURL.
Сохранение данных в таблицу через методы родителя.
EBooking:
Хранение данных о заказе и функции для их проверки.
Repository:
Абстрактный класс с методами для создания SQL-запросов и вызова методов DB.
Entity:
Базовый класс для проверки данных.
DB:
Класс для работы с БД через PDO.
Index:
Инициализация приложения и запуск необходимых функций для добавления заказа.

Задание 2
Некоторые события нужно продавать с дополнительными типами билетов - льготный и групповой, у которых будут свои цены и название. Имеется информация, что вероятно, будут другие типы билетов, которые нужно будет добавить. Нужно уметь сохранять при заказе 2 дополнительных типа билета, льготный и групповой в бд. Задача - Нормализовать таблицу учитывая добавленные типы билетов, показать конечный вид таблицы. Объяснить свое решение.
Часто посетители из одного заказа приходят не одновременно на события. Возникает необходимость проверять их билеты по отдельности. Для этого у каждого билета должен быть свой баркод. Если в одном заказе было куплено несколько билетов, 2 взрослых, 3 детских, 4 льготных - то должно быть 9 баркодов для каждого билета соответственно. Задача - Нормализовать таблицу, учитывая что у каждого билета свой баркод, показать конечный вид таблицы. Объяснить свое решение.
Изначальная таблица:
id
event_id
event_date
ticket_adult_price
ticket_adult_quantity
ticket_kid_price
ticket_kid_quantity
barcode
user_id
equal_price
created



Решение:
Для того чтобы приспособить таблицу к хранению множества типов билетов нужно:
Сделать отдельную таблицу для всех типов билетов (tickets_type)(Задание 2.1). Так же для нормализации основной таблицы я бы сделал отдельную таблицу event, для хранения информации о событии, отдельную таблицу users, для хранении информации о пользователе. Делаем мы их потому что таблица избыточна и не приспособлена для нормального хранения данных билетов. В новых таблицах мы можем спокойно добавлять нужные новые параметры.

Таблица tickets_type

id
event_id
Name
Price


Event_id - имеет связь с id из таблицы event
Таблица event

id
data
info


Таблица users

id
info


Исходя из 2.2 нам требуется присваивать каждому купленному билету свой barcode, для этого сразу же сделаем отдельную таблицу с tickets и таблицу с заказами  (orders). Так как нам нужно хранить баркод для каждого билета отдельно наилучшем вариантом с моей точки зрение будет отдельное хранение каждого билета в виде записи в свою таблицу.
Таблица tickets:

barcode
order_id
event_id
ticket_type_id

Так как barcode у нас является уникальным для каждого билета, он является id(primery_key)
Order_id - имеет связь с id из таблицы orders
Event_id - имеет связь с id из таблицы event
Ticket_type_id - имеет связь с id из таблицы ticket_type

Таблица orders:

id
user_id
equal_price
created

User_id - имеет связь с id из таблицы users

В конечном итоге мы разделили начальную таблицу на 5 таблиц которые отвечают за свои данные. В этой структуре мы можем хранить множество типов билетов и информацию о них (Задание 2.1). И так же присваивать каждому билету свой barcode (Задание 2.2)
